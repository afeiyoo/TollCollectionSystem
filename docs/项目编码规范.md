# 项目编码规范

规则并非一成不变。如果你有充分的理由打破规则，那就去做吧。但首先要确保至少有其他开发者同意你的观点。请遵守以下规则：

- 最重要的规则是保持简短（*KISS，keep it short and simple*）。始终选择更简单的实现方案，而不是更复杂的方案。这会让维护变得容易得多。
- 编写优秀的 C++ 代码。也就是说，代码要可读性强、注释清晰、面向对象。
- 不要重复造轮子。充分利用Qt提供的方法。
- 遵循下文代码构造，格式化，设计与实践等指导

# 业务名词命名规范

| 名词     | 变量命名            |
| -------- | ------------------- |
| 门架     | gantry              |
| 复式车道 | dualLane            |
| 路径     | 统一以dir或path结尾 |



# 代码构造

1. 尝试尽量减少对同一代码的重复计算。 特别是循环的时候（**注意地址越界**）例如：

    ```cpp
    Container::iterator end = large.end();
    for (Container::iterator it = large.begin(); it != end; ++it) {
        ...;
    }
    
    -NOT-
    
    for (Container::iterator it = large.begin(); it != large.end(); ++it) {
            ...;
    }
    ```

2. 建议在项目里使用迭代器 for 循环遍历容器，避免使用Qt的 `foreach` 循环（它会对容器进行临时拷贝，带来额外性能开销）。**同时，建议循环变量使用 `const` 修饰，以避免意外修改元素。**

    ```cpp
    for (auto& itor = container.begin(); itor != container.end(); ++itor) {
        doSomething(itor);
    }
    
    -NOT-
    
    foreach (Widget* widget, container)
        doSomething(widget);
    ```

    **现代化范围 for 循环也是推荐的。**

# 格式化

## 标识符

在标识符中使用驼峰大小写。充分利用标识符中的第一个字符，如下所示：

1. 类名以大写字母开头，使用“C”前缀约定，例如：`class CMyClass;`

2. 变量名采用驼峰命名，例如：`int myVar;`

3. 枚举声明使用枚举类。枚举类以大写字母开头，使用“EM_”前缀约定。枚举值以全大写命名，并用下划线分隔。例如：

    ```cpp
    enum class EM_VerticesPerEvent { NO_VERTICES = 0, VERTICES_FOR_SAMEHEIGHT = 4, VERTICES_FOR_DIFFERENT_HEIGHT = 6 };
    ```

4. 结构体名称以大写字母开头，使用“ST_”前缀约定。内部变量以驼峰命名，例如：

    ```c++
    struct ST_LogConfig
    {
        QString format;
        uint filesLimit;
    };
    ```

5. 类成员变量使用驼峰命名，使用"m_"前缀约定。

## 空格

1. 使用四个空格来进行缩进，不要使用制表符Tab。
2. 使用空白行将相关联代码进行分隔。
3. 始终仅使用一个空白行。

## 指针和引用

对于指针或引用，请始终在星号（*）或与号（＆）之前使用单个空格，但不要在其后使用。尽可能避免使用C语言类型转换：

```cpp
char *blockOfMemory = (char *)malloc(data.size());
char *blockOfMemory = reinterpret_cast<char *>(malloc(data.size()));
  
-NOT-
  
char* blockOfMemory = (char* ) malloc(data.size());
```

当然，在这个特殊的例子中，可能使用new更合适。

## 函数名称和括号

1. 函数名称使用驼峰命名。
1. 不要在函数名称和括号之间使用空格：

```cpp
void mangle()
-NOT-
void mangle ()
```

## 关键字

请始终在关键字和大括号之间使用一个空格：

```cpp
if (foo) {
}

-NOT-

if(foo){
}
```

## 注释

通常，在“//”之后放置一个空格。要对齐多行注释中的文本，可以插入多个空格。

## 大括号

作为基本规则，将左大括号与语句开头放在同一行：

```cpp
if (codec) {
}
  
-NOT-
  
if (codec)
{
}
```

例外：函数实现和类声明的左括号始终在行首处：

```cpp
static void foo(int g)
{
    qDebug("foo: %i", g);
}
class Mo
{
};
```

当条件语句的主体包含多行时，以及单行语句有些复杂时，请使用大括号。 否则，请省略它们：

```cpp
if (address.isEmpty())
    return false;
for (int i = 0; i < 10; ++i)
    qDebug("%i", i);
      
-NOT-
  
if (address.isEmpty()) {
    return false;
}
for (int i = 0; i < 10; ++i) {
    qDebug("%i", i);
}
```

例外1：如果括号中的条件语句包含多行或进行了换行，也请使用大括号：

```cpp
if (address.isEmpty()
        || !isValid()
        || !codec) {
    return false;
}
```

注意：这可以重写为：

```cpp
if (address.isEmpty())
    return false;
if (!isValid())
    return false;
if (!codec)
    return false;
```

例外2：在if-then-else块中，如果if-code或else-code覆盖多行，也请使用大括号：

```cpp
if (address.isEmpty()) {
    --it;
} else {
    qDebug("%s", qPrintable(address));
    ++it;
}
-NOT-
if (address.isEmpty())
    --it;
else {
    qDebug("%s", qPrintable(address));
    ++it;
}
  
if (a) {
    if (b)
        ...
    else
        ...
}
-NOT-
if (a)
    if (b)
        ...
    else
        ...
```

当条件语句的主体为空时，请使用大括号：

```cpp
while (a) {}
-NOT-
while (a);
```

## 小括号

使用括号将表达式分组：

```cpp
if ((a && b) || c)
-NOT-
if (a && b || c)

(a + b) & c
-NOT-
a + b & c
```

## 换行

1. 确保每行少于180个字符。
2. 如有必要，请插入换行符。
3. 逗号放在行的结尾。
4. 操作符放在新行的开头。
   
    ```cpp
    if (longExpression
        || otherLongExpression
        || otherOtherLongExpression) {
    }
    
    -NOT-
    
    if (longExpression ||
        otherLongExpression ||
        otherOtherLongExpression) {
    }
    ```
    

## 声明

1. 对类的访问部分使用以下顺序：公有，受保护，私有。 公有部分对类的每个用户都很有用。 私有部分仅对该类的实现者有用。
2. 在类的声明文件中，避免声明全局对象。 如果所有对象都使用相同的变量，请使用静态成员。
3. 使用 `class` 而不是 `struct` 。一些编译器会在符号名称中混入差异，并在struct声明后跟class声明时发出警告。 为了避免持续更改来消除警告，我们将 `class` 声明作为首选方式。
4. 自定义信号的声明前加上sig前缀，以代表信号。自定义槽函数的声明前加上on前缀，以代表槽函数
   
    ```cpp
    signals:
        void sigChange();
    public slots:
        void onChange();
    ```
    
5. 变量声明
    - 避免使用类类型的全局变量，来排除初始化顺序的问题。如果无法避免，请考虑使用 `Q_GLOBAL_STATIC` 。
    - 声明全局字符串文本方式如下：
      
        ```cpp
        const char aString[] = "Hello";
        ```
        
    - 尽可能避免使用短名称（例如a，rbarr，nughdeget）。仅将单字符变量名称用于计数器和临时变量，其用途是显而易见。
    - 每个变量声明在单独的行中：
      
        ```cpp
        QString a = "Joe";
        QString b = "Foo";
        
        -NOT-
        
        QString a = "Joe", b = "Foo";
        ```
        
    - 避免缩写：
      
        ```cpp
        int height;
        int width;
        char *nameOfThis;
        char *nameOfThat;
        
        -NOT-
        
        int a, b;
        char *c, *d;
        ```
        
    - 当变量被需要时，才进行声明。声明时完成初始化，这一点尤其重要。

## 命名空间

1. 将左大括号与namespace关键字放在同一行。
2. 不要缩进内部的声明或定义。
   
    ```cpp
    namespace MyPlugin {
    void someFunction() {
        ...
    }
    }  // namespace MyPlugin
    
    -NOT-
    
    namespace MyPlugin {
        void someFunction() {
            ...
        }
    }  // namespace MyPlugin
    ```
    
3. 可选，但如果名称空间跨越多行，则建议使用：在右大括号后添加注释，重复该名称空间。
   
    ```cpp
    namespace MyPlugin {
    void someFunction() { ... }
    }  // namespace MyPlugin
    
    ```
    
4. 作为例外，如果名称空间中只有一个类声明，则可以都放在一行上：
   
    ```cpp
    namespace MyPlugin { class MyClass; }
    ```
    
5. 不要在头文件中使用using指令。
6. 定义类和函数时不要依赖using指令，而应在适当的命名声明区域中对其进行定义。
7. 访问全局函数时，请勿依赖using指令。
8. 在其他情况下，建议您使用using指令，因为它们可帮助您避免混乱的代码。 最好将所有的using指令放在文件顶部附近，#include之后。
   
    ```cpp
    [in foo.cpp]
    ...
    #include "foos.h"
    ...
    #include <utils/filename.h>
    ...
    using namespace Utils;
    namespace Foo {
    namespace Internal {
    void SomeThing::bar()
    {
        FileName f;              // or Utils::FileName f
        ...
    }
    ...
    } // namespace Internal      // or only // Internal
    } // namespace Foo           // or only // Foo
    
    -NOT-
    
    [in foo.h]
    ...
    using namespace Utils;       // Wrong: 在头文件中直接使用using指令
    class SomeThing
    {
        ...
    };
    
    -NOT-
    
    [in foo.cpp]
    ...
    using namespace Utils;
    #include "bar.h"             // Wrong: 最好将所有的using指令放在文件顶部附近，#include之后
    
    -NOT-
    
    [in foo.cpp]
    ...
    using namepace Foo;
    void SomeThing::bar()        // Wrong if Something is in namespace Foo
    {
        ...
    }
    
    ```
    

# 设计与实践

## 文件路径的传递

使用可移植格式的文件路径，即在Windows系统上也要使用斜杠 `/` 而不是反斜杠 `\` 。传递用户输入的文件路径给API，请先使用 `QDir::fromNativeSeparators` 对其进行转换。要向用户显示文件名，请使用 `QDir::toNativeSeparators` 将其转换回本地格式。

对于这些任务，请考虑使用 `Utils::FileName::fromUserInput(QString)` 和 `Utils::FileName::toUserOutput()` 。比较文件名时请使用 `Utils::FileName` ，因为它是大小写敏感的。

还要确保文件夹使用的路径，是没有使用相对路径的（`QDir::cleanPath()`），例如：

```cpp
QString absPath = QDir::cleanPath(QDir(basePath).absoluteFilePath(relPath));
```

## 尽可能使用静态关键字代替匿名命名空间。

```cpp
static int internalHelper() { ... }  // 限制作用于当前编译单元

-NOT-

namespace {
int internalHelper() { ... }  // C++ 标准视为外部链接
}
```

## 对于空指针推荐使用nullptr。

```cpp
void *p = nullptr;  // 正确、简洁

-NOT-

void *p = 0;      // 陈旧语法
void *p = NULL;   // 宏，类型不安全
void *p = '\0';   // 字符类型
```

## Lambdas

您不必显式指定返回类型。 注意：这是C++ 14功能，您可能需要在编译器中启用C++ 14支持。

```cpp
[]() {
    Foo *foo = activeFoo();
    return foo ? foo->displayName() : QString();
};
```

根据以下规则格式化lambda：

1. 将函数调用的右圆括号和分号与lambda的右大括号放在同一行。
   
    ```cpp
    foo([]() {
        something();
    });
    ```
    
2. 如果在'if'语句中使用lambda，请在新行上启动lambda，以避免在lambda的左大括号和'if'语句的左大括号之间造成混淆。
   
    ```cpp
    if (anyOf(fooList,
            [](Foo foo) {
                return foo.isGreat();
            }) {
        return;
    }
    
    -NOT-
    
    if (anyOf(fooList, [](Foo foo) {
                return foo.isGreat();
            }) {
        return;
    }
    
    ```
    
3. **可选，**如果合适，将lambda完整地放在同一行。
   
    ```cpp
    foo([] { return true; });
    if (foo([] { return true; })) {
        ...
    }
    ```
    
4. 把捕获列表，参数列表，返回类型和左括号放在第一行，在接下来的几行中缩进主体，在新的一行上关闭右括号。
   
    ```cpp
    []() -> bool {
        something();
        return isSomethingElse();
    }
    
    -NOT-
    
    []() -> bool { something();
    somethingElse(); }
    ```
    

## auto关键字

`auto` 可以让你不写出变量的完整类型，**但要合理使用，不要滥用。**请记住，读代码的次数比写代码的次数要多。**可选**，在以下情况下，可以使用auto关键字。

1. 避免在同一条语句中重复某个类型。
   
    ```cpp
    auto something = new MyCustomType;
    auto keyEvent = static_cast<QKeyEvent *>(event);
    auto myList = QStringList({ "FooThing",  "BarThing" });
    ```
    
2. 分配迭代器类型时，`auto it = myList.const_iterator();`

## 初始化列表

使用初始化列表来初始化容器，例如：

```cpp
  const QVector<int> values = {1, 2, 3, 4, 5};
```

## 覆写

覆写虚函数时，建议使用`override`关键字。不要在已覆写函数上使用`virtual`。

确保一个类内对所有被覆盖的函数始终使用`override`，以区分没有被覆盖的。

## 信号槽的连接

信号槽的连接使用函数指针的方式进行连接，而非宏SLOT与SIGNAL。因为使用函数指针的方式可以在编译时检测语法错误。

```cpp
connect(ui->lineEdit, &QLineEdit::textEdited, this, &Obj::onTextEdited);

-NOT-

connect(ui->lineEdit, SIGNAL(textEdited(QString)), this, SLOT(onTextEdited(QString)));
```

## 类型转换

1. 避免使用C强制转换，最好使用C++强制转换（static_cast，const_cast，reinterpret_cast）。虽然reinterpret_cast和C类型强制转换都是危险的，但是至少reinterpret_cast不会删除const修饰符。
2. 除非您知道要做什么，否则不要使用dynamic_cast，对QObject使用qobject_cast。

## 全局静态变量声明

1. 对于头文件中的静态声明，请坚持使用整数类型，整数类型数组及其结构。任何具有构造函数或需要运行代码进行初始化的对象，都不能作为库代码的全局对象，因为该构造函数或代码何时运行未定义（首次使用时，库加载时，main()之前或根本不进行）。
   
    ```cpp
    // 编译期常量：x 是纯数组，不涉及构造函数
    static const char x[] = "someText";
    
    // 整数初始化，无需运行代码
    static int y = 7;
    
    // 简单 POD 类型（Plain Old Data）
    struct MyStruct { int a, b, c; };
    static MyStruct s = {1, 2, 3};
    
    // 指针为 null，不需要运行构造函数
    static QString *ptr = nullptr;
    
    -NOT-
    
    // 1. 需要调用默认构造函数
    static const QString x;  // ❌ 初始化点未知
    
    // 2. 需要运行带参数的构造函数
    static const QString y = "Hello";  // ❌ 非常危险
    
    // 3. 变量可能根本不会构造
    QString z;  // ❌ 插件或静态库中容易出错
    
    // 4. foo() 返回值依赖函数运行，时机不确定
    static const int i = foo();  // ❌ foo 可能不会被调用
    ```
    
2. Qt 提供了线程安全的全局懒加载机制
   
    ```cpp
    Q_GLOBAL_STATIC(QString, s)
    
    void foo() {
        s()->append("moo");
    }
    ```
    
    这样只有在首次访问 `s()` 时才会调用构造函数进行初始化。
